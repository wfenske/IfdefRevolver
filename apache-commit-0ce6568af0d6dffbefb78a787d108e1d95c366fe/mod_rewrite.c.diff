 /* Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 /*                       _                            _ _
  *   _ __ ___   ___   __| |    _ __ _____      ___ __(_) |_ ___
  *  | '_ ` _ \ / _ \ / _` |   | '__/ _ \ \ /\ / / '__| | __/ _ \
  *  | | | | | | (_) | (_| |   | | |  __/\ V  V /| |  | | ||  __/
  *  |_| |_| |_|\___/ \__,_|___|_|  \___| \_/\_/ |_|  |_|\__\___|
  *                       |_____|
  *
  *  URL Rewriting Module
  *
  *  This module uses a rule-based rewriting engine (based on a
  *  regular-expression parser) to rewrite requested URLs on the fly.
  *
  *  It supports an unlimited number of additional rule conditions (which can
  *  operate on a lot of variables, even on HTTP headers) for granular
  *  matching and even external database lookups (either via plain text
  *  tables, DBM hash files or even external processes) for advanced URL
  *  substitution.
  *
  *  It operates on the full URLs (including the PATH_INFO part) both in
  *  per-server context (httpd.conf) and per-dir context (.htaccess) and even
  *  can generate QUERY_STRING parts on result.   The rewriting result finally
  *  can lead to internal subprocessing, external request redirection or even
  *  to internal proxy throughput.
  *
  *  This module was originally written in April 1996 and
  *  gifted exclusively to the The Apache Software Foundation in July 1997 by
  *
  *      Ralf S. Engelschall
  *      rse engelschall.com
  *      www.engelschall.com
  */
 
 #include "apr.h"
 #include "apr_strings.h"
 #include "apr_hash.h"
 #include "apr_user.h"
 #include "apr_lib.h"
 #include "apr_signal.h"
 #include "apr_global_mutex.h"
 #include "apr_dbm.h"
 
 #if APR_HAS_THREADS
 #include "apr_thread_mutex.h"
 #endif
 
 #define APR_WANT_MEMFUNC
 #define APR_WANT_STRFUNC
 #define APR_WANT_IOVEC
 #include "apr_want.h"
 
 /* XXX: Do we really need these headers? */
 #if APR_HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #if APR_HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #if APR_HAVE_STDARG_H
 #include <stdarg.h>
 #endif
 #if APR_HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #if APR_HAVE_CTYPE_H
 #include <ctype.h>
 #endif
 
 #include "ap_config.h"
 #include "httpd.h"
 #include "http_config.h"
 #include "http_request.h"
 #include "http_core.h"
 #include "http_log.h"
 #include "http_protocol.h"
 #include "http_vhost.h"
 
 #include "mod_ssl.h"
 
 #include "mod_rewrite.h"
 
 #ifdef AP_NEED_SET_MUTEX_PERMS
 #include "unixd.h"
 #endif
 
 /*
  * in order to improve performance on running production systems, you
  * may strip all rewritelog code entirely from mod_rewrite by using the
  * -DREWRITELOG_DISABLED compiler option.
  *
  * DO NOT USE THIS OPTION FOR PUBLIC BINARY RELEASES. Otherwise YOU are
  * responsible for answering all the mod_rewrite questions out there.
  */
 #ifndef REWRITELOG_DISABLED
 
 #define rewritelog(x) do_rewritelog x
 #define REWRITELOG_MODE  ( APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD )
 #define REWRITELOG_FLAGS ( APR_WRITE | APR_APPEND | APR_CREATE )
 
 #else /* !REWRITELOG_DISABLED */
 
 #define rewritelog(x)
 
 #endif /* REWRITELOG_DISABLED */
 
 /* remembered mime-type for [T=...] */
 #define REWRITE_FORCED_MIMETYPE_NOTEVAR "rewrite-forced-mimetype"
 #define REWRITE_FORCED_HANDLER_NOTEVAR  "rewrite-forced-handler"
 
 #define ENVVAR_SCRIPT_URL "SCRIPT_URL"
 #define REDIRECT_ENVVAR_SCRIPT_URL "REDIRECT_" ENVVAR_SCRIPT_URL
 #define ENVVAR_SCRIPT_URI "SCRIPT_URI"
 
 #define CONDFLAG_NONE               1<<0
 #define CONDFLAG_NOCASE             1<<1
 #define CONDFLAG_NOTMATCH           1<<2
 #define CONDFLAG_ORNEXT             1<<3
 #define CONDFLAG_NOVARY             1<<4
 
 #define RULEFLAG_NONE               1<<0
 #define RULEFLAG_FORCEREDIRECT      1<<1
 #define RULEFLAG_LASTRULE           1<<2
 #define RULEFLAG_NEWROUND           1<<3
 #define RULEFLAG_CHAIN              1<<4
 #define RULEFLAG_IGNOREONSUBREQ     1<<5
 #define RULEFLAG_NOTMATCH           1<<6
 #define RULEFLAG_PROXY              1<<7
 #define RULEFLAG_PASSTHROUGH        1<<8
 #define RULEFLAG_QSAPPEND           1<<9
 #define RULEFLAG_NOCASE             1<<10
 #define RULEFLAG_NOESCAPE           1<<11
 #define RULEFLAG_NOSUB              1<<12
 #define RULEFLAG_STATUS             1<<13
 #define RULEFLAG_ESCAPEBACKREF      1<<14
 
 /* return code of the rewrite rule
  * the result may be escaped - or not
  */
 #define ACTION_NORMAL               1<<0
 #define ACTION_NOESCAPE             1<<1
 #define ACTION_STATUS               1<<2
 
 
 #define MAPTYPE_TXT                 1<<0
 #define MAPTYPE_DBM                 1<<1
 #define MAPTYPE_PRG                 1<<2
 #define MAPTYPE_INT                 1<<3
 #define MAPTYPE_RND                 1<<4
 
 #define ENGINE_DISABLED             1<<0
 #define ENGINE_ENABLED              1<<1
 
 #define OPTION_NONE                 1<<0
 #define OPTION_INHERIT              1<<1
 
 #ifndef RAND_MAX
 #define RAND_MAX 32767
 #endif
 
 /* max cookie size in rfc 2109 */
 /* XXX: not used at all. We should do a check somewhere and/or cut the cookie */
 #define MAX_COOKIE_LEN 4096
 
 /* max line length (incl.\n) in text rewrite maps */
 #ifndef REWRITE_MAX_TXT_MAP_LINE
 #define REWRITE_MAX_TXT_MAP_LINE 1024
 #endif
 
 /* buffer length for prg rewrite maps */
 #ifndef REWRITE_PRG_MAP_BUF
 #define REWRITE_PRG_MAP_BUF 1024
 #endif
 
 /* for better readbility */
 #define LEFT_CURLY  '{'
 #define RIGHT_CURLY '}'
 
 /*
  * expansion result items on the stack to save some cycles
  *
  * (5 == about 2 variables like "foo%{var}bar%{var}baz")
  */
 #define SMALL_EXPANSION 5
 
 /*
  * check that a subrequest won't cause infinite recursion
  *
  * either not in a subrequest, or in a subrequest
  * and URIs aren't NULL and sub/main URIs differ
  */
 #define subreq_ok(r) (!r->main || \
     (r->main->uri && r->uri && strcmp(r->main->uri, r->uri)))
 
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |                 Types and Structures
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 typedef struct {
     const char *datafile;          /* filename for map data files         */
     const char *dbmtype;           /* dbm type for dbm map data files     */
     const char *checkfile;         /* filename to check for map existence */
     const char *cachename;         /* for cached maps (txt/rnd/dbm)       */
     int   type;                    /* the type of the map                 */
     apr_file_t *fpin;              /* in  file pointer for program maps   */
     apr_file_t *fpout;             /* out file pointer for program maps   */
     apr_file_t *fperr;             /* err file pointer for program maps   */
     char *(*func)(request_rec *,   /* function pointer for internal maps  */
                   char *);
     char **argv;                   /* argv of the external rewrite map    */
     const char *checkfile2;        /* filename to check for map existence
                                       NULL if only one file               */
 } rewritemap_entry;
 
 /* special pattern types for RewriteCond */
 typedef enum {
     CONDPAT_REGEX = 0,
     CONDPAT_FILE_EXISTS,
     CONDPAT_FILE_SIZE,
     CONDPAT_FILE_LINK,
     CONDPAT_FILE_DIR,
     CONDPAT_FILE_XBIT,
     CONDPAT_LU_URL,
     CONDPAT_LU_FILE,
     CONDPAT_STR_GT,
     CONDPAT_STR_LT,
     CONDPAT_STR_EQ
 } pattern_type;
 
 typedef struct {
     char        *input;   /* Input string of RewriteCond   */
     char        *pattern; /* the RegExp pattern string     */
     ap_regex_t  *regexp;  /* the precompiled regexp        */
     int          flags;   /* Flags which control the match */
     pattern_type ptype;   /* pattern type                  */
 } rewritecond_entry;
 
 /* single linked list for env vars and cookies */
 typedef struct data_item {
     struct data_item *next;
     char *data;
 } data_item;
 
 typedef struct {
     apr_array_header_t *rewriteconds;/* the corresponding RewriteCond entries */
     char      *pattern;              /* the RegExp pattern string             */
     ap_regex_t *regexp;              /* the RegExp pattern compilation        */
     char      *output;               /* the Substitution string               */
     int        flags;                /* Flags which control the substitution  */
     char      *forced_mimetype;      /* forced MIME type of substitution      */
     char      *forced_handler;       /* forced content handler of subst.      */
     int        forced_responsecode;  /* forced HTTP response status           */
     data_item *env;                  /* added environment variables           */
     data_item *cookie;               /* added cookies                         */
     int        skip;                 /* number of next rules to skip          */
 } rewriterule_entry;
 
 typedef struct {
     int           state;              /* the RewriteEngine state            */
     int           options;            /* the RewriteOption state            */
 #ifndef REWRITELOG_DISABLED
     const char   *rewritelogfile;     /* the RewriteLog filename            */
     apr_file_t   *rewritelogfp;       /* the RewriteLog open filepointer    */
     int           rewriteloglevel;    /* the RewriteLog level of verbosity  */
 #endif
     apr_hash_t         *rewritemaps;  /* the RewriteMap entries             */
     apr_array_header_t *rewriteconds; /* the RewriteCond entries (temp.)    */
     apr_array_header_t *rewriterules; /* the RewriteRule entries            */
     server_rec   *server;             /* the corresponding server indicator */
 } rewrite_server_conf;
 
 typedef struct {
     int           state;              /* the RewriteEngine state           */
     int           options;            /* the RewriteOption state           */
     apr_array_header_t *rewriteconds; /* the RewriteCond entries (temp.)   */
     apr_array_header_t *rewriterules; /* the RewriteRule entries           */
     char         *directory;          /* the directory where it applies    */
     const char   *baseurl;            /* the base-URL  where it applies    */
 } rewrite_perdir_conf;
 
 /* the (per-child) cache structures.
  */
 typedef struct cache {
     apr_pool_t         *pool;
     apr_hash_t         *maps;
 #if APR_HAS_THREADS
     apr_thread_mutex_t *lock;
 #endif
 } cache;
 
 /* cached maps contain an mtime for the whole map and live in a subpool
  * of the cachep->pool. That makes it easy to forget them if necessary.
  */
 typedef struct {
     apr_time_t mtime;
     apr_pool_t *pool;
     apr_hash_t *entries;
 } cachedmap;
 
 /* the regex structure for the
  * substitution of backreferences
  */
 typedef struct backrefinfo {
     char *source;
     int nsub;
     ap_regmatch_t regmatch[AP_MAX_REG_MATCH];
 } backrefinfo;
 
 /* single linked list used for
  * variable expansion
  */
 typedef struct result_list {
     struct result_list *next;
     apr_size_t len;
     const char *string;
 } result_list;
 
 /* context structure for variable lookup and expansion
  */
 typedef struct {
     request_rec *r;
     const char  *uri;
     const char  *vary_this;
     const char  *vary;
     char        *perdir;
     backrefinfo briRR;
     backrefinfo briRC;
 } rewrite_ctx;
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |                 static module data
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 /* the global module structure */
 module AP_MODULE_DECLARE_DATA rewrite_module;
 
 /* rewritemap int: handler function registry */
 static apr_hash_t *mapfunc_hash;
 
 /* the cache */
 static cache *cachep;
 
 /* whether proxy module is available or not */
 static int proxy_available;
 
 /* whether random seed can be reaped */
 static int rewrite_rand_init_done = 0;
 
 /* Locks/Mutexes */
 static const char *lockname;
 static apr_global_mutex_t *rewrite_mapr_lock_acquire = NULL;
 
 #ifndef REWRITELOG_DISABLED
 static apr_global_mutex_t *rewrite_log_lock = NULL;
 #endif
 
 /* Optional functions imported from mod_ssl when loaded: */
 static APR_OPTIONAL_FN_TYPE(ssl_var_lookup) *rewrite_ssl_lookup = NULL;
 static APR_OPTIONAL_FN_TYPE(ssl_is_https) *rewrite_is_https = NULL;
+static char *escape_uri(apr_pool_t *p, const char *path);
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |              rewriting logfile support
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 #ifndef REWRITELOG_DISABLED
 static char *current_logtime(request_rec *r)
 {
     apr_time_exp_t t;
     char tstr[80];
     apr_size_t len;
 
     apr_time_exp_lt(&t, apr_time_now());
 
     apr_strftime(tstr, &len, sizeof(tstr), "[%d/%b/%Y:%H:%M:%S ", &t);
     apr_snprintf(tstr+len, sizeof(tstr)-len, "%c%.2d%.2d]",
                  t.tm_gmtoff < 0 ? '-' : '+',
                  t.tm_gmtoff / (60*60), t.tm_gmtoff % (60*60));
 
     return apr_pstrdup(r->pool, tstr);
 }
 
 static int open_rewritelog(server_rec *s, apr_pool_t *p)
 {
     rewrite_server_conf *conf;
     const char *fname;
 
     conf = ap_get_module_config(s->module_config, &rewrite_module);
 
     /* - no logfile configured
      * - logfilename empty
      * - virtual log shared w/ main server
      */
     if (!conf->rewritelogfile || !*conf->rewritelogfile || conf->rewritelogfp) {
         return 1;
     }
 
     if (*conf->rewritelogfile == '|') {
         piped_log *pl;
 
         fname = ap_server_root_relative(p, conf->rewritelogfile+1);
         if (!fname) {
             ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
                          "mod_rewrite: Invalid RewriteLog "
                          "path %s", conf->rewritelogfile+1);
             return 0;
         }
 
         if ((pl = ap_open_piped_log(p, fname)) == NULL) {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                          "mod_rewrite: could not open reliable pipe "
                          "to RewriteLog filter %s", fname);
             return 0;
         }
         conf->rewritelogfp = ap_piped_log_write_fd(pl);
     }
     else {
         apr_status_t rc;
 
         fname = ap_server_root_relative(p, conf->rewritelogfile);
         if (!fname) {
             ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
                          "mod_rewrite: Invalid RewriteLog "
                          "path %s", conf->rewritelogfile);
             return 0;
         }
 
         if ((rc = apr_file_open(&conf->rewritelogfp, fname,
                                 REWRITELOG_FLAGS, REWRITELOG_MODE, p))
                 != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, rc, s,
                          "mod_rewrite: could not open RewriteLog "
                          "file %s", fname);
             return 0;
         }
     }
 
     return 1;
 }
 
 static void do_rewritelog(request_rec *r, int level, char *perdir,
                           const char *fmt, ...)
 {
     rewrite_server_conf *conf;
     char *logline, *text;
     const char *rhost, *rname;
     apr_size_t nbytes;
     int redir;
     apr_status_t rv;
     request_rec *req;
     va_list ap;
 
     conf = ap_get_module_config(r->server->module_config, &rewrite_module);
 
     if (!conf->rewritelogfp || level > conf->rewriteloglevel) {
         return;
     }
 
     rhost = ap_get_remote_host(r->connection, r->per_dir_config,
                                REMOTE_NOLOOKUP, NULL);
     rname = ap_get_remote_logname(r);
 
     for (redir=0, req=r; req->prev; req = req->prev) {
         ++redir;
     }
 
     va_start(ap, fmt);
     text = apr_pvsprintf(r->pool, fmt, ap);
     va_end(ap);
 
     logline = apr_psprintf(r->pool, "%s %s %s %s [%s/sid#%pp][rid#%pp/%s%s%s] "
                                     "(%d) %s%s%s%s" APR_EOL_STR,
                            rhost ? rhost : "UNKNOWN-HOST",
                            rname ? rname : "-",
                            r->user ? (*r->user ? r->user : "\"\"") : "-",
                            current_logtime(r),
                            ap_get_server_name(r),
                            (void *)(r->server),
                            (void *)r,
                            r->main ? "subreq" : "initial",
                            redir ? "/redir#" : "",
                            redir ? apr_itoa(r->pool, redir) : "",
                            level,
                            perdir ? "[perdir " : "",
                            perdir ? perdir : "",
                            perdir ? "] ": "",
                            text);
 
     rv = apr_global_mutex_lock(rewrite_log_lock);
     if (rv != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                       "apr_global_mutex_lock(rewrite_log_lock) failed");
         /* XXX: Maybe this should be fatal? */
     }
 
     nbytes = strlen(logline);
     apr_file_write(conf->rewritelogfp, logline, &nbytes);
 
     rv = apr_global_mutex_unlock(rewrite_log_lock);
     if (rv != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                       "apr_global_mutex_unlock(rewrite_log_lock) failed");
         /* XXX: Maybe this should be fatal? */
     }
 
     return;
 }
 #endif /* !REWRITELOG_DISABLED */
 
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |                URI and path functions
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 /* return number of chars of the scheme (incl. '://')
  * if the URI is absolute (includes a scheme etc.)
  * otherwise 0.
  *
  * NOTE: If you add new schemes here, please have a
  *       look at escape_absolute_uri and splitout_queryargs.
  *       Not every scheme takes query strings and some schemes
  *       may be handled in a special way.
  *
  * XXX: we may consider a scheme registry, perhaps with
  *      appropriate escape callbacks to allow other modules
  *      to extend mod_rewrite at runtime.
  */
 static unsigned is_absolute_uri(char *uri)
 {
     /* fast exit */
     if (*uri == '/' || strlen(uri) <= 5) {
         return 0;
     }
 
     switch (*uri++) {
     case 'a':
     case 'A':
         if (!strncasecmp(uri, "jp://", 5)) {        /* ajp://    */
           return 6;
         }
 
     case 'b':
     case 'B':
         if (!strncasecmp(uri, "alancer://", 10)) {   /* balancer:// */
           return 11;
         }
         break;
 
     case 'f':
     case 'F':
         if (!strncasecmp(uri, "tp://", 5)) {        /* ftp://    */
             return 6;
         }
         break;
 
     case 'g':
     case 'G':
         if (!strncasecmp(uri, "opher://", 8)) {     /* gopher:// */
             return 9;
         }
         break;
 
     case 'h':
     case 'H':
         if (!strncasecmp(uri, "ttp://", 6)) {       /* http://   */
             return 7;
         }
         else if (!strncasecmp(uri, "ttps://", 7)) { /* https://  */
             return 8;
         }
         break;
 
     case 'l':
     case 'L':
         if (!strncasecmp(uri, "dap://", 6)) {       /* ldap://   */
             return 7;
         }
         break;
 
     case 'm':
     case 'M':
         if (!strncasecmp(uri, "ailto:", 6)) {       /* mailto:   */
             return 7;
         }
         break;
 
     case 'n':
     case 'N':
         if (!strncasecmp(uri, "ews:", 4)) {         /* news:     */
             return 5;
         }
         else if (!strncasecmp(uri, "ntp://", 6)) {  /* nntp://   */
             return 7;
         }
         break;
     }
 
     return 0;
 }
 
+static const char c2x_table[] = "0123456789abcdef";
+
+static APR_INLINE unsigned char *c2x(unsigned what, unsigned char prefix,
+                                     unsigned char *where)
+{
+#if APR_CHARSET_EBCDIC
+    what = apr_xlate_conv_byte(ap_hdrs_to_ascii, (unsigned char)what);
+#endif /*APR_CHARSET_EBCDIC*/
+    *where++ = prefix;
+    *where++ = c2x_table[what >> 4];
+    *where++ = c2x_table[what & 0xf];
+    return where;
+}
+
+/*
+ * Escapes a uri in a similar way as php's urlencode does.
+ * Based on ap_os_escape_path in server/util.c
+ */
+static char *escape_uri(apr_pool_t *p, const char *path) {
+    char *copy = apr_palloc(p, 3 * strlen(path) + 3);
+    const unsigned char *s = (const unsigned char *)path;
+    unsigned char *d = (unsigned char *)copy;
+    unsigned c;
+
+    while ((c = *s)) {
+        if (apr_isalnum(c) || c == '_') {
+            *d++ = c;
+        }
+        else if (c == ' ') {
+            *d++ = '+';
+        }
+        else {
+            d = c2x(c, '%', d);
+        }
+        ++s;
+    }
+    *d = '\0';
+    return copy;
+}
+
 /*
  * escape absolute uri, which may or may not be path oriented.
  * So let's handle them differently.
  */
 static char *escape_absolute_uri(apr_pool_t *p, char *uri, unsigned scheme)
 {
     char *cp;
 
     /* be safe.
      * NULL should indicate elsewhere, that something's wrong
      */
     if (!scheme || strlen(uri) < scheme) {
         return NULL;
     }
 
     cp = uri + scheme;
 
     /* scheme with authority part? */
     if (cp[-1] == '/') {
         /* skip host part */
         while (*cp && *cp != '/') {
             ++cp;
         }
 
         /* nothing after the hostpart. ready! */
         if (!*cp || !*++cp) {
             return apr_pstrdup(p, uri);
         }
 
         /* remember the hostname stuff */
         scheme = cp - uri;
 
         /* special thing for ldap.
          * The parts are separated by question marks. From RFC 2255:
          *     ldapurl = scheme "://" [hostport] ["/"
          *               [dn ["?" [attributes] ["?" [scope]
          *               ["?" [filter] ["?" extensions]]]]]]
          */
         if (!strncasecmp(uri, "ldap", 4)) {
             char *token[5];
             int c = 0;
 
             token[0] = cp = apr_pstrdup(p, cp);
             while (*cp && c < 4) {
                 if (*cp == '?') {
                     token[++c] = cp + 1;
                     *cp = '\0';
                 }
                 ++cp;
             }
 
             return apr_pstrcat(p, apr_pstrndup(p, uri, scheme),
                                           ap_escape_uri(p, token[0]),
                                (c >= 1) ? "?" : NULL,
                                (c >= 1) ? ap_escape_uri(p, token[1]) : NULL,
                                (c >= 2) ? "?" : NULL,
                                (c >= 2) ? ap_escape_uri(p, token[2]) : NULL,
                                (c >= 3) ? "?" : NULL,
                                (c >= 3) ? ap_escape_uri(p, token[3]) : NULL,
                                (c >= 4) ? "?" : NULL,
                                (c >= 4) ? ap_escape_uri(p, token[4]) : NULL,
                                NULL);
         }
     }
 
     /* Nothing special here. Apply normal escaping. */
     return apr_pstrcat(p, apr_pstrndup(p, uri, scheme),
                        ap_escape_uri(p, cp), NULL);
 }
 
 /*
  * split out a QUERY_STRING part from
  * the current URI string
  */
 static void splitout_queryargs(request_rec *r, int qsappend)
 {
     char *q;
 
     /* don't touch, unless it's an http or mailto URL.
      * See RFC 1738 and RFC 2368.
      */
     if (is_absolute_uri(r->filename)
         && strncasecmp(r->filename, "ajp", 3)
         && strncasecmp(r->filename, "balancer", 8)
         && strncasecmp(r->filename, "http", 4)
         && strncasecmp(r->filename, "mailto", 6)) {
         r->args = NULL; /* forget the query that's still flying around */
         return;
     }
 
     q = ap_strchr(r->filename, '?');
     if (q != NULL) {
         char *olduri;
         apr_size_t len;
 
         olduri = apr_pstrdup(r->pool, r->filename);
         *q++ = '\0';
         if (qsappend) {
             r->args = apr_pstrcat(r->pool, q, "&", r->args, NULL);
         }
         else {
             r->args = apr_pstrdup(r->pool, q);
         }
 
         len = strlen(r->args);
         if (!len) {
             r->args = NULL;
         }
         else if (r->args[len-1] == '&') {
             r->args[len-1] = '\0';
         }
 
         rewritelog((r, 3, NULL, "split uri=%s -> uri=%s, args=%s", olduri,
                     r->filename, r->args ? r->args : "<none>"));
     }
 
     return;
 }
 
 /*
  * strip 'http[s]://ourhost/' from URI
  */
 static void reduce_uri(request_rec *r)
 {
     char *cp;
     apr_size_t l;
 
     cp = (char *)ap_http_scheme(r);
     l  = strlen(cp);
     if (   strlen(r->filename) > l+3
         && strncasecmp(r->filename, cp, l) == 0
         && r->filename[l]   == ':'
         && r->filename[l+1] == '/'
         && r->filename[l+2] == '/' ) {
 
         unsigned short port;
         char *portp, *host, *url, *scratch;
 
         scratch = apr_pstrdup(r->pool, r->filename); /* our scratchpad */
 
         /* cut the hostname and port out of the URI */
         cp = host = scratch + l + 3;    /* 3 == strlen("://") */
         while (*cp && *cp != '/' && *cp != ':') {
             ++cp;
         }
 
         if (*cp == ':') {      /* additional port given */
             *cp++ = '\0';
             portp = cp;
             while (*cp && *cp != '/') {
                 ++cp;
             }
             *cp = '\0';
 
             port = atoi(portp);
             url = r->filename + (cp - scratch);
             if (!*url) {
                 url = "/";
             }
         }
         else if (*cp == '/') { /* default port */
             *cp = '\0';
 
             port = ap_default_port(r);
             url = r->filename + (cp - scratch);
         }
         else {
             port = ap_default_port(r);
             url = "/";
         }
 
         /* now check whether we could reduce it to a local path... */
         if (ap_matches_request_vhost(r, host, port)) {
             rewritelog((r, 3, NULL, "reduce %s -> %s", r->filename, url));
             r->filename = apr_pstrdup(r->pool, url);
         }
     }
 
     return;
 }
 
 /*
  * add 'http[s]://ourhost[:ourport]/' to URI
  * if URI is still not fully qualified
  */
 static void fully_qualify_uri(request_rec *r)
 {
     if (!is_absolute_uri(r->filename)) {
         const char *thisserver;
         char *thisport;
         int port;
 
         thisserver = ap_get_server_name(r);
         port = ap_get_server_port(r);
         thisport = ap_is_default_port(port, r)
                    ? ""
                    : apr_psprintf(r->pool, ":%u", port);
 
         r->filename = apr_psprintf(r->pool, "%s://%s%s%s%s",
                                    ap_http_scheme(r), thisserver, thisport,
                                    (*r->filename == '/') ? "" : "/",
                                    r->filename);
     }
 
     return;
 }
 
 /*
  * stat() only the first segment of a path
  */
 static int prefix_stat(const char *path, apr_pool_t *pool)
 {
     const char *curpath = path;
     const char *root;
     const char *slash;
     char *statpath;
     apr_status_t rv;
 
     rv = apr_filepath_root(&root, &curpath, APR_FILEPATH_TRUENAME, pool);
 
     if (rv != APR_SUCCESS) {
         return 0;
     }
 
     /* let's recognize slashes only, the mod_rewrite semantics are opaque
      * enough.
      */
     if ((slash = ap_strchr_c(curpath, '/')) != NULL) {
         rv = apr_filepath_merge(&statpath, root,
                                 apr_pstrndup(pool, curpath,
                                              (apr_size_t)(slash - curpath)),
                                 APR_FILEPATH_NOTABOVEROOT |
                                 APR_FILEPATH_NOTRELATIVE, pool);
     }
     else {
         rv = apr_filepath_merge(&statpath, root, curpath,
                                 APR_FILEPATH_NOTABOVEROOT |
                                 APR_FILEPATH_NOTRELATIVE, pool);
     }
 
     if (rv == APR_SUCCESS) {
         apr_finfo_t sb;
 
         if (apr_stat(&sb, statpath, APR_FINFO_MIN, pool) == APR_SUCCESS) {
             return 1;
         }
     }
 
     return 0;
 }
 
 /*
  * substitute the prefix path 'match' in 'input' with 'subst' (RewriteBase)
  */
 static char *subst_prefix_path(request_rec *r, char *input, char *match,
                                const char *subst)
 {
     apr_size_t len = strlen(match);
 
     if (len && match[len - 1] == '/') {
         --len;
     }
 
     if (!strncmp(input, match, len) && input[len++] == '/') {
         apr_size_t slen, outlen;
         char *output;
 
         rewritelog((r, 5, NULL, "strip matching prefix: %s -> %s", input,
                     input+len));
 
         slen = strlen(subst);
         if (slen && subst[slen - 1] != '/') {
             ++slen;
         }
 
         outlen = strlen(input) + slen - len;
         output = apr_palloc(r->pool, outlen + 1); /* don't forget the \0 */
 
         memcpy(output, subst, slen);
         if (slen && !output[slen-1]) {
             output[slen-1] = '/';
         }
         memcpy(output+slen, input+len, outlen - slen);
         output[outlen] = '\0';
 
         rewritelog((r, 4, NULL, "add subst prefix: %s -> %s", input+len,
                     output));
 
         return output;
     }
 
     /* prefix didn't match */
     return input;
 }
 
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |                    caching support
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 static void set_cache_value(const char *name, apr_time_t t, char *key,
                             char *val)
 {
     cachedmap *map;
 
     if (cachep) {
 #if APR_HAS_THREADS
         apr_thread_mutex_lock(cachep->lock);
 #endif
         map = apr_hash_get(cachep->maps, name, APR_HASH_KEY_STRING);
 
         if (!map) {
             apr_pool_t *p;
 
             if (apr_pool_create(&p, cachep->pool) != APR_SUCCESS) {
 #if APR_HAS_THREADS
                 apr_thread_mutex_unlock(cachep->lock);
 #endif
                 return;
             }
 
             map = apr_palloc(cachep->pool, sizeof(cachedmap));
             map->pool = p;
             map->entries = apr_hash_make(map->pool);
             map->mtime = t;
 
             apr_hash_set(cachep->maps, name, APR_HASH_KEY_STRING, map);
         }
         else if (map->mtime != t) {
             apr_pool_clear(map->pool);
             map->entries = apr_hash_make(map->pool);
             map->mtime = t;
         }
 
         /* Now we should have a valid map->entries hash, where we
          * can store our value.
          *
          * We need to copy the key and the value into OUR pool,
          * so that we don't leave it during the r->pool cleanup.
          */
         apr_hash_set(map->entries,
                      apr_pstrdup(map->pool, key), APR_HASH_KEY_STRING,
                      apr_pstrdup(map->pool, val));
 
 #if APR_HAS_THREADS
         apr_thread_mutex_unlock(cachep->lock);
 #endif
     }
 
     return;
 }
 
 static char *get_cache_value(const char *name, apr_time_t t, char *key,
                              apr_pool_t *p)
 {
     cachedmap *map;
     char *val = NULL;
 
     if (cachep) {
 #if APR_HAS_THREADS
         apr_thread_mutex_lock(cachep->lock);
 #endif
         map = apr_hash_get(cachep->maps, name, APR_HASH_KEY_STRING);
 
         if (map) {
             /* if this map is outdated, forget it. */
             if (map->mtime != t) {
                 apr_pool_clear(map->pool);
                 map->entries = apr_hash_make(map->pool);
                 map->mtime = t;
             }
             else {
                 val = apr_hash_get(map->entries, key, APR_HASH_KEY_STRING);
                 if (val) {
                     /* copy the cached value into the supplied pool,
                      * where it belongs (r->pool usually)
                      */
                     val = apr_pstrdup(p, val);
                 }
             }
         }
 
 #if APR_HAS_THREADS
         apr_thread_mutex_unlock(cachep->lock);
 #endif
     }
 
     return val;
 }
 
 static int init_cache(apr_pool_t *p)
 {
     cachep = apr_palloc(p, sizeof(cache));
     if (apr_pool_create(&cachep->pool, p) != APR_SUCCESS) {
         cachep = NULL; /* turns off cache */
         return 0;
     }
 
     cachep->maps = apr_hash_make(cachep->pool);
 #if APR_HAS_THREADS
     (void)apr_thread_mutex_create(&(cachep->lock), APR_THREAD_MUTEX_DEFAULT, p);
 #endif
 
     return 1;
 }
 
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |                    Map Functions
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 /*
  * General Note: key is already a fresh string, created (expanded) just
  * for the purpose to be passed in here. So one can modify key itself.
  */
 
 static char *rewrite_mapfunc_toupper(request_rec *r, char *key)
 {
     char *p;
 
     for (p = key; *p; ++p) {
         *p = apr_toupper(*p);
     }
 
     return key;
 }
 
 static char *rewrite_mapfunc_tolower(request_rec *r, char *key)
 {
     ap_str_tolower(key);
 
     return key;
 }
 
 static char *rewrite_mapfunc_escape(request_rec *r, char *key)
 {
     return ap_escape_uri(r->pool, key);
 }
 
 static char *rewrite_mapfunc_unescape(request_rec *r, char *key)
 {
     ap_unescape_url(key);
 
     return key;
 }
 
 static char *select_random_value_part(request_rec *r, char *value)
 {
     char *p = value;
     unsigned n = 1;
 
     /* count number of distinct values */
     while ((p = ap_strchr(p, '|')) != NULL) {
         ++n;
         ++p;
     }
 
     if (n > 1) {
         /* initialize random generator
          *
          * XXX: Probably this should be wrapped into a thread mutex,
          * shouldn't it? Is it worth the effort?
          */
         if (!rewrite_rand_init_done) {
             srand((unsigned)(getpid()));
             rewrite_rand_init_done = 1;
         }
 
         /* select a random subvalue */
         n = (int)(((double)(rand() % RAND_MAX) / RAND_MAX) * n + 1);
 
         /* extract it from the whole string */
         while (--n && (value = ap_strchr(value, '|')) != NULL) {
             ++value;
         }
 
         if (value) { /* should not be NULL, but ... */
             p = ap_strchr(value, '|');
             if (p) {
                 *p = '\0';
             }
         }
     }
 
     return value;
 }
 
 /* child process code */
 static void rewrite_child_errfn(apr_pool_t *p, apr_status_t err,
                                 const char *desc)
 {
     ap_log_error(APLOG_MARK, APLOG_ERR, err, NULL, "%s", desc);
 }
 
 static apr_status_t rewritemap_program_child(apr_pool_t *p,
                                              const char *progname, char **argv,
                                              apr_file_t **fpout,
                                              apr_file_t **fpin)
 {
     apr_status_t rc;
     apr_procattr_t *procattr;
     apr_proc_t *procnew;
 
     if (   APR_SUCCESS == (rc=apr_procattr_create(&procattr, p))
         && APR_SUCCESS == (rc=apr_procattr_io_set(procattr, APR_FULL_BLOCK,
                                                   APR_FULL_BLOCK, APR_NO_PIPE))
         && APR_SUCCESS == (rc=apr_procattr_dir_set(procattr,
                                              ap_make_dirstr_parent(p, argv[0])))
         && APR_SUCCESS == (rc=apr_procattr_cmdtype_set(procattr, APR_PROGRAM))
         && APR_SUCCESS == (rc=apr_procattr_child_errfn_set(procattr,
                                                            rewrite_child_errfn))
         && APR_SUCCESS == (rc=apr_procattr_error_check_set(procattr, 1))) {
 
         procnew = apr_pcalloc(p, sizeof(*procnew));
         rc = apr_proc_create(procnew, argv[0], (const char **)argv, NULL,
                              procattr, p);
 
         if (rc == APR_SUCCESS) {
             apr_pool_note_subprocess(p, procnew, APR_KILL_AFTER_TIMEOUT);
 
             if (fpin) {
                 (*fpin) = procnew->in;
             }
 
             if (fpout) {
                 (*fpout) = procnew->out;
             }
         }
     }
 
     return (rc);
 }
 
 static apr_status_t run_rewritemap_programs(server_rec *s, apr_pool_t *p)
 {
     rewrite_server_conf *conf;
     apr_hash_index_t *hi;
     apr_status_t rc;
     int lock_warning_issued = 0;
 
     conf = ap_get_module_config(s->module_config, &rewrite_module);
 
     /*  If the engine isn't turned on,
      *  don't even try to do anything.
      */
     if (conf->state == ENGINE_DISABLED) {
         return APR_SUCCESS;
     }
 
     for (hi = apr_hash_first(p, conf->rewritemaps); hi; hi = apr_hash_next(hi)){
         apr_file_t *fpin = NULL;
         apr_file_t *fpout = NULL;
         rewritemap_entry *map;
         void *val;
 
         apr_hash_this(hi, NULL, NULL, &val);
         map = val;
 
         if (map->type != MAPTYPE_PRG) {
             continue;
         }
         if (!(map->argv[0]) || !*(map->argv[0]) || map->fpin || map->fpout) {
             continue;
         }
 
         if (!lock_warning_issued && (!lockname || !*lockname)) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
                          "mod_rewrite: Running external rewrite maps "
                          "without defining a RewriteLock is DANGEROUS!");
             ++lock_warning_issued;
         }
 
         rc = rewritemap_program_child(p, map->argv[0], map->argv,
                                       &fpout, &fpin);
         if (rc != APR_SUCCESS || fpin == NULL || fpout == NULL) {
             ap_log_error(APLOG_MARK, APLOG_ERR, rc, s,
                          "mod_rewrite: could not start RewriteMap "
                          "program %s", map->checkfile);
             return rc;
         }
         map->fpin  = fpin;
         map->fpout = fpout;
     }
 
     return APR_SUCCESS;
 }
 
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |                  Lookup functions
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 static char *lookup_map_txtfile(request_rec *r, const char *file, char *key)
 {
     apr_file_t *fp = NULL;
     char line[REWRITE_MAX_TXT_MAP_LINE + 1]; /* +1 for \0 */
     char *value, *keylast;
 
     if (apr_file_open(&fp, file, APR_READ|APR_BUFFERED, APR_OS_DEFAULT,
                       r->pool) != APR_SUCCESS) {
         return NULL;
     }
 
     keylast = key + strlen(key);
     value = NULL;
     while (apr_file_gets(line, sizeof(line), fp) == APR_SUCCESS) {
         char *p, *c;
 
         /* ignore comments and lines starting with whitespaces */
         if (*line == '#' || apr_isspace(*line)) {
             continue;
         }
 
         p = line;
         c = key;
         while (c < keylast && *p == *c && !apr_isspace(*p)) {
             ++p;
             ++c;
         }
 
         /* key doesn't match - ignore. */
         if (c != keylast || !apr_isspace(*p)) {
             continue;
         }
 
         /* jump to the value */
         while (*p && apr_isspace(*p)) {
             ++p;
         }
 
         /* no value? ignore */
         if (!*p) {
             continue;
         }
 
         /* extract the value and return. */
         c = p;
         while (*p && !apr_isspace(*p)) {
             ++p;
         }
         value = apr_pstrmemdup(r->pool, c, p - c);
         break;
     }
     apr_file_close(fp);
 
     return value;
 }
 
 static char *lookup_map_dbmfile(request_rec *r, const char *file,
                                 const char *dbmtype, char *key)
 {
     apr_dbm_t *dbmfp = NULL;
     apr_datum_t dbmkey;
     apr_datum_t dbmval;
     char *value;
 
     if (apr_dbm_open_ex(&dbmfp, dbmtype, file, APR_DBM_READONLY, APR_OS_DEFAULT,
                         r->pool) != APR_SUCCESS) {
         return NULL;
     }
 
     dbmkey.dptr  = key;
     dbmkey.dsize = strlen(key);
 
     if (apr_dbm_fetch(dbmfp, dbmkey, &dbmval) == APR_SUCCESS && dbmval.dptr) {
         value = apr_pstrmemdup(r->pool, dbmval.dptr, dbmval.dsize);
     }
     else {
         value = NULL;
     }
 
     apr_dbm_close(dbmfp);
 
     return value;
 }
 
 static char *lookup_map_program(request_rec *r, apr_file_t *fpin,
                                 apr_file_t *fpout, char *key)
 {
     char *buf;
     char c;
     apr_size_t i, nbytes, combined_len = 0;
     apr_status_t rv;
     const char *eol = APR_EOL_STR;
     apr_size_t eolc = 0;
     int found_nl = 0;
     result_list *buflist = NULL, *curbuf = NULL;
 
 #ifndef NO_WRITEV
     struct iovec iova[2];
     apr_size_t niov;
 #endif
 
     /* when `RewriteEngine off' was used in the per-server
      * context then the rewritemap-programs were not spawned.
      * In this case using such a map (usually in per-dir context)
      * is useless because it is not available.
      *
      * newlines in the key leave bytes in the pipe and cause
      * bad things to happen (next map lookup will use the chars
      * after the \n instead of the new key etc etc - in other words,
      * the Rewritemap falls out of sync with the requests).
      */
     if (fpin == NULL || fpout == NULL || ap_strchr(key, '\n')) {
         return NULL;
     }
 
     /* take the lock */
     if (rewrite_mapr_lock_acquire) {
         rv = apr_global_mutex_lock(rewrite_mapr_lock_acquire);
         if (rv != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                           "apr_global_mutex_lock(rewrite_mapr_lock_acquire) "
                           "failed");
             return NULL; /* Maybe this should be fatal? */
         }
     }
 
     /* write out the request key */
 #ifdef NO_WRITEV
     nbytes = strlen(key);
     apr_file_write(fpin, key, &nbytes);
     nbytes = 1;
     apr_file_write(fpin, "\n", &nbytes);
 #else
     iova[0].iov_base = key;
     iova[0].iov_len = strlen(key);
     iova[1].iov_base = "\n";
     iova[1].iov_len = 1;
 
     niov = 2;
     apr_file_writev(fpin, iova, niov, &nbytes);
 #endif
 
     buf = apr_palloc(r->pool, REWRITE_PRG_MAP_BUF + 1);
 
     /* read in the response value */
     nbytes = 1;
     apr_file_read(fpout, &c, &nbytes);
     do {
         i = 0;
         while (nbytes == 1 && (i < REWRITE_PRG_MAP_BUF)) {
             if (c == eol[eolc]) {
                 if (!eol[++eolc]) {
                     /* remove eol from the buffer */
                     --eolc;
                     if (i < eolc) {
                         curbuf->len -= eolc-i;
                         i = 0;
                     }
                     else {
                         i -= eolc;
                     }
                     ++found_nl;
                     break;
                 }
             }
 
             /* only partial (invalid) eol sequence -> reset the counter */
             else if (eolc) {
                 eolc = 0;
             }
 
             /* catch binary mode, e.g. on Win32 */
             else if (c == '\n') {
                 ++found_nl;
                 break;
             }
 
             buf[i++] = c;
             apr_file_read(fpout, &c, &nbytes);
         }
 
         /* well, if there wasn't a newline yet, we need to read further */
         if (buflist || (nbytes == 1 && !found_nl)) {
             if (!buflist) {
                 curbuf = buflist = apr_palloc(r->pool, sizeof(*buflist));
             }
             else if (i) {
                 curbuf->next = apr_palloc(r->pool, sizeof(*buflist));
                 curbuf = curbuf->next;
 
             }
             curbuf->next = NULL;
 
             if (i) {
                 curbuf->string = buf;
                 curbuf->len = i;
                 combined_len += i;
                 buf = apr_palloc(r->pool, REWRITE_PRG_MAP_BUF);
             }
 
             if (nbytes == 1 && !found_nl) {
                 i = 0;
                 continue;
             }
         }
 
         break;
     } while (1);
 
     /* concat the stuff */
     if (buflist) {
         char *p;
 
         p = buf = apr_palloc(r->pool, combined_len + 1); /* \0 */
         while (buflist) {
             if (buflist->len) {
                 memcpy(p, buflist->string, buflist->len);
                 p += buflist->len;
             }
             buflist = buflist->next;
         }
         *p = '\0';
         i = combined_len;
     }
     else {
         buf[i] = '\0';
     }
 
     /* give the lock back */
     if (rewrite_mapr_lock_acquire) {
         rv = apr_global_mutex_unlock(rewrite_mapr_lock_acquire);
         if (rv != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                           "apr_global_mutex_unlock(rewrite_mapr_lock_acquire) "
                           "failed");
             return NULL; /* Maybe this should be fatal? */
         }
     }
 
     /* catch the "failed" case */
     if (i == 4 && !strcasecmp(buf, "NULL")) {
         return NULL;
     }
 
     return buf;
 }
 
 /*
  * generic map lookup
  */
 static char *lookup_map(request_rec *r, char *name, char *key)
 {
     rewrite_server_conf *conf;
     rewritemap_entry *s;
     char *value;
     apr_finfo_t st;
     apr_status_t rv;
 
     /* get map configuration */
     conf = ap_get_module_config(r->server->module_config, &rewrite_module);
     s = apr_hash_get(conf->rewritemaps, name, APR_HASH_KEY_STRING);
 
     /* map doesn't exist */
     if (!s) {
         return NULL;
     }
 
     switch (s->type) {
     /*
      * Text file map (perhaps random)
      */
     case MAPTYPE_RND:
     case MAPTYPE_TXT:
         rv = apr_stat(&st, s->checkfile, APR_FINFO_MIN, r->pool);
         if (rv != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                           "mod_rewrite: can't access text RewriteMap file %s",
                           s->checkfile);
             rewritelog((r, 1, NULL,
                         "can't open RewriteMap file, see error log"));
             return NULL;
         }
 
         value = get_cache_value(s->cachename, st.mtime, key, r->pool);
         if (!value) {
             rewritelog((r, 6, NULL,
                         "cache lookup FAILED, forcing new map lookup"));
 
             value = lookup_map_txtfile(r, s->datafile, key);
             if (!value) {
                 rewritelog((r, 5, NULL, "map lookup FAILED: map=%s[txt] key=%s",
                             name, key));
                 set_cache_value(s->cachename, st.mtime, key, "");
                 return NULL;
             }
 
             rewritelog((r, 5, NULL,"map lookup OK: map=%s[txt] key=%s -> val=%s",
                         name, key, value));
             set_cache_value(s->cachename, st.mtime, key, value);
         }
         else {
             rewritelog((r,5,NULL,"cache lookup OK: map=%s[txt] key=%s -> val=%s",
                         name, key, value));
         }
 
         if (s->type == MAPTYPE_RND && *value) {
             value = select_random_value_part(r, value);
             rewritelog((r, 5, NULL, "randomly chosen the subvalue `%s'",value));
         }
 
         return *value ? value : NULL;
 
     /*
      * DBM file map
      */
     case MAPTYPE_DBM:
         rv = apr_stat(&st, s->checkfile, APR_FINFO_MIN, r->pool);
         if (rv != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                           "mod_rewrite: can't access DBM RewriteMap file %s",
                           s->checkfile);
         }
         else if(s->checkfile2 != NULL) {
             apr_finfo_t st2;
 
             rv = apr_stat(&st2, s->checkfile2, APR_FINFO_MIN, r->pool);
             if (rv != APR_SUCCESS) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                               "mod_rewrite: can't access DBM RewriteMap "
                               "file %s", s->checkfile2);
             }
             else if(st2.mtime > st.mtime) {
                 st.mtime = st2.mtime;
             }
         }
         if(rv != APR_SUCCESS) {
             rewritelog((r, 1, NULL,
                         "can't open DBM RewriteMap file, see error log"));
             return NULL;
         }
 
         value = get_cache_value(s->cachename, st.mtime, key, r->pool);
         if (!value) {
             rewritelog((r, 6, NULL,
                         "cache lookup FAILED, forcing new map lookup"));
 
             value = lookup_map_dbmfile(r, s->datafile, s->dbmtype, key);
             if (!value) {
                 rewritelog((r, 5, NULL, "map lookup FAILED: map=%s[dbm] key=%s",
                             name, key));
                 set_cache_value(s->cachename, st.mtime, key, "");
                 return NULL;
             }
 
             rewritelog((r, 5, NULL, "map lookup OK: map=%s[dbm] key=%s -> "
                         "val=%s", name, key, value));
 
             set_cache_value(s->cachename, st.mtime, key, value);
             return value;
         }
 
         rewritelog((r, 5, NULL, "cache lookup OK: map=%s[dbm] key=%s -> val=%s",
                     name, key, value));
         return *value ? value : NULL;
 
     /*
      * Program file map
      */
     case MAPTYPE_PRG:
         value = lookup_map_program(r, s->fpin, s->fpout, key);
         if (!value) {
             rewritelog((r, 5,NULL,"map lookup FAILED: map=%s key=%s", name,
                         key));
             return NULL;
         }
 
         rewritelog((r, 5, NULL, "map lookup OK: map=%s key=%s -> val=%s",
                     name, key, value));
         return value;
 
     /*
      * Internal Map
      */
     case MAPTYPE_INT:
         value = s->func(r, key);
         if (!value) {
             rewritelog((r, 5,NULL,"map lookup FAILED: map=%s key=%s", name,
                         key));
             return NULL;
         }
 
         rewritelog((r, 5, NULL, "map lookup OK: map=%s key=%s -> val=%s",
                     name, key, value));
         return value;
     }
 
     return NULL;
 }
 
 /*
  * lookup a HTTP header and set VARY note
  */
 static const char *lookup_header(const char *name, rewrite_ctx *ctx)
 {
     const char *val = apr_table_get(ctx->r->headers_in, name);
 
     if (val) {
         ctx->vary_this = ctx->vary_this
                          ? apr_pstrcat(ctx->r->pool, ctx->vary_this, ", ",
                                        name, NULL)
                          : apr_pstrdup(ctx->r->pool, name);
     }
 
     return val;
 }
 
 /*
  * lookahead helper function
  * Determine the correct URI path in perdir context
  */
 static APR_INLINE const char *la_u(rewrite_ctx *ctx)
 {
     rewrite_perdir_conf *conf;
 
     if (*ctx->uri == '/') {
         return ctx->uri;
     }
 
     conf = ap_get_module_config(ctx->r->per_dir_config, &rewrite_module);
 
     return apr_pstrcat(ctx->r->pool, conf->baseurl
                                      ? conf->baseurl : conf->directory,
                        ctx->uri, NULL);
 }
 
 /*
  * generic variable lookup
  */
 static char *lookup_variable(char *var, rewrite_ctx *ctx)
 {
     const char *result;
     request_rec *r = ctx->r;
     apr_size_t varlen = strlen(var);
 
     /* fast exit */
     if (varlen < 4) {
         return apr_pstrdup(r->pool, "");
     }
 
     result = NULL;
 
     /* fast tests for variable length variables (sic) first */
     if (var[3] == ':') {
         if (var[4] && !strncasecmp(var, "ENV", 3)) {
             var += 4;
             result = apr_table_get(r->notes, var);
 
             if (!result) {
                 result = apr_table_get(r->subprocess_env, var);
             }
             if (!result) {
                 result = getenv(var);
             }
         }
         else if (var[4] && !strncasecmp(var, "SSL", 3) && rewrite_ssl_lookup) {
             result = rewrite_ssl_lookup(r->pool, r->server, r->connection, r,
                                         var + 4);
         }
     }
     else if (var[4] == ':') {
         if (var[5]) {
             request_rec *rr;
             const char *path;
 
             if (!strncasecmp(var, "HTTP", 4)) {
                 result = lookup_header(var+5, ctx);
             }
             else if (!strncasecmp(var, "LA-U", 4)) {
                 if (ctx->uri && subreq_ok(r)) {
                     path = ctx->perdir ? la_u(ctx) : ctx->uri;
                     rr = ap_sub_req_lookup_uri(path, r, NULL);
                     ctx->r = rr;
                     result = apr_pstrdup(r->pool, lookup_variable(var+5, ctx));
                     ctx->r = r;
                     ap_destroy_sub_req(rr);
 
                     rewritelog((r, 5, ctx->perdir, "lookahead: path=%s var=%s "
                                 "-> val=%s", path, var+5, result));
 
                     return (char *)result;
                 }
             }
             else if (!strncasecmp(var, "LA-F", 4)) {
                 if (ctx->uri && subreq_ok(r)) {
                     path = ctx->uri;
                     if (ctx->perdir && *path == '/') {
                         /* sigh, the user wants a file based subrequest, but
                          * we can't do one, since we don't know what the file
                          * path is! In this case behave like LA-U.
                          */
                         rr = ap_sub_req_lookup_uri(path, r, NULL);
                     }
                     else {
                         if (ctx->perdir) {
                             rewrite_perdir_conf *conf;
 
                             conf = ap_get_module_config(r->per_dir_config,
                                                         &rewrite_module);
 
                             path = apr_pstrcat(r->pool, conf->directory, path,
                                                NULL);
                         }
 
                         rr = ap_sub_req_lookup_file(path, r, NULL);
                     }
 
                     ctx->r = rr;
                     result = apr_pstrdup(r->pool, lookup_variable(var+5, ctx));
                     ctx->r = r;
                     ap_destroy_sub_req(rr);
 
                     rewritelog((r, 5, ctx->perdir, "lookahead: path=%s var=%s "
                                 "-> val=%s", path, var+5, result));
 
                     return (char *)result;
                 }
             }
         }
     }
 
     /* well, do it the hard way */
     else {
         char *p;
         apr_time_exp_t tm;
 
         /* can't do this above, because of the getenv call */
         for (p = var; *p; ++p) {
             *p = apr_toupper(*p);
         }
 
         switch (varlen) {
         case  4:
             if (!strcmp(var, "TIME")) {
                 apr_time_exp_lt(&tm, apr_time_now());
                 result = apr_psprintf(r->pool, "%04d%02d%02d%02d%02d%02d",
                                       tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday,
                                       tm.tm_hour, tm.tm_min, tm.tm_sec);
                 rewritelog((r, 1, ctx->perdir, "RESULT='%s'", result));
                 return (char *)result;
             }
             break;
 
         case  5:
             if (!strcmp(var, "HTTPS")) {
                 int flag = rewrite_is_https && rewrite_is_https(r->connection);
                 return apr_pstrdup(r->pool, flag ? "on" : "off");
             }
             break;
 
         case  8:
             switch (var[6]) {
             case 'A':
                 if (!strcmp(var, "TIME_DAY")) {
                     apr_time_exp_lt(&tm, apr_time_now());
                     return apr_psprintf(r->pool, "%02d", tm.tm_mday);
                 }
                 break;
 
             case 'E':
                 if (!strcmp(var, "TIME_SEC")) {
                     apr_time_exp_lt(&tm, apr_time_now());
                     return apr_psprintf(r->pool, "%02d", tm.tm_sec);
                 }
                 break;
 
             case 'I':
                 if (!strcmp(var, "TIME_MIN")) {
                     apr_time_exp_lt(&tm, apr_time_now());
                     return apr_psprintf(r->pool, "%02d", tm.tm_min);
                 }
                 break;
 
             case 'O':
                 if (!strcmp(var, "TIME_MON")) {
                     apr_time_exp_lt(&tm, apr_time_now());
                     return apr_psprintf(r->pool, "%02d", tm.tm_mon+1);
                 }
                 break;
             }
             break;
 
         case  9:
             switch (var[7]) {
             case 'A':
                 if (var[8] == 'Y' && !strcmp(var, "TIME_WDAY")) {
                     apr_time_exp_lt(&tm, apr_time_now());
                     return apr_psprintf(r->pool, "%d", tm.tm_wday);
                 }
                 else if (!strcmp(var, "TIME_YEAR")) {
                     apr_time_exp_lt(&tm, apr_time_now());
                     return apr_psprintf(r->pool, "%04d", tm.tm_year+1900);
                 }
                 break;
 
             case 'E':
                 if (!strcmp(var, "IS_SUBREQ")) {
                     result = (r->main ? "true" : "false");
                 }
                 break;
 
             case 'F':
                 if (!strcmp(var, "PATH_INFO")) {
                     result = r->path_info;
                 }
                 break;
 
             case 'P':
                 if (!strcmp(var, "AUTH_TYPE")) {
                     result = r->ap_auth_type;
                 }
                 break;
 
             case 'S':
                 if (!strcmp(var, "HTTP_HOST")) {
                     result = lookup_header("Host", ctx);
                 }
                 break;
 
             case 'U':
                 if (!strcmp(var, "TIME_HOUR")) {
                     apr_time_exp_lt(&tm, apr_time_now());
                     return apr_psprintf(r->pool, "%02d", tm.tm_hour);
                 }
                 break;
             }
             break;
 
         case 11:
             switch (var[8]) {
             case 'A':
                 if (!strcmp(var, "SERVER_NAME")) {
                     result = ap_get_server_name(r);
                 }
                 break;
 
             case 'D':
                 if (*var == 'R' && !strcmp(var, "REMOTE_ADDR")) {
                     result = r->connection->remote_ip;
                 }
                 else if (!strcmp(var, "SERVER_ADDR")) {
                     result = r->connection->local_ip;
                 }
                 break;
 
             case 'E':
                 if (*var == 'H' && !strcmp(var, "HTTP_ACCEPT")) {
                     result = lookup_header("Accept", ctx);
                 }
                 else if (!strcmp(var, "THE_REQUEST")) {
                     result = r->the_request;
                 }
                 break;
 
             case 'I':
                 if (!strcmp(var, "API_VERSION")) {
                     return apr_psprintf(r->pool, "%d:%d",
                                         MODULE_MAGIC_NUMBER_MAJOR,
                                         MODULE_MAGIC_NUMBER_MINOR);
                 }
                 break;
 
             case 'K':
                 if (!strcmp(var, "HTTP_COOKIE")) {
                     result = lookup_header("Cookie", ctx);
                 }
                 break;
 
             case 'O':
                 if (*var == 'S' && !strcmp(var, "SERVER_PORT")) {
                     return apr_psprintf(r->pool, "%u", ap_get_server_port(r));
                 }
                 else if (var[7] == 'H' && !strcmp(var, "REMOTE_HOST")) {
                     result = ap_get_remote_host(r->connection,r->per_dir_config,
                                                 REMOTE_NAME, NULL);
                 }
                 else if (!strcmp(var, "REMOTE_PORT")) {
                     return apr_itoa(r->pool, r->connection->remote_addr->port);
                 }
                 break;
 
             case 'S':
                 if (*var == 'R' && !strcmp(var, "REMOTE_USER")) {
                     result = r->user;
                 }
                 else if (!strcmp(var, "SCRIPT_USER")) {
                     result = "<unknown>";
                     if (r->finfo.valid & APR_FINFO_USER) {
                         apr_uid_name_get((char **)&result, r->finfo.user,
                                          r->pool);
                     }
                 }
                 break;
 
             case 'U':
                 if (!strcmp(var, "REQUEST_URI")) {
                     result = r->uri;
                 }
                 break;
             }
             break;
 
         case 12:
             switch (var[3]) {
             case 'I':
                 if (!strcmp(var, "SCRIPT_GROUP")) {
                     result = "<unknown>";
                     if (r->finfo.valid & APR_FINFO_GROUP) {
                         apr_gid_name_get((char **)&result, r->finfo.group,
                                          r->pool);
                     }
                 }
                 break;
 
             case 'O':
                 if (!strcmp(var, "REMOTE_IDENT")) {
                     result = ap_get_remote_logname(r);
                 }
                 break;
 
             case 'P':
                 if (!strcmp(var, "HTTP_REFERER")) {
                     result = lookup_header("Referer", ctx);
                 }
                 break;
 
             case 'R':
                 if (!strcmp(var, "QUERY_STRING")) {
                     result = r->args;
                 }
                 break;
 
             case 'V':
                 if (!strcmp(var, "SERVER_ADMIN")) {
                     result = r->server->server_admin;
                 }
                 break;
             }
             break;
 
         case 13:
             if (!strcmp(var, "DOCUMENT_ROOT")) {
                 result = ap_document_root(r);
             }
             break;
 
         case 14:
             if (*var == 'H' && !strcmp(var, "HTTP_FORWARDED")) {
                 result = lookup_header("Forwarded", ctx);
             }
             else if (!strcmp(var, "REQUEST_METHOD")) {
                 result = r->method;
             }
             break;
 
         case 15:
             switch (var[7]) {
             case 'E':
                 if (!strcmp(var, "HTTP_USER_AGENT")) {
                     result = lookup_header("User-Agent", ctx);
                 }
                 break;
 
             case 'F':
                 if (!strcmp(var, "SCRIPT_FILENAME")) {
                     result = r->filename; /* same as request_filename (16) */
                 }
                 break;
 
             case 'P':
                 if (!strcmp(var, "SERVER_PROTOCOL")) {
                     result = r->protocol;
                 }
                 break;
 
             case 'S':
                 if (!strcmp(var, "SERVER_SOFTWARE")) {
                     result = ap_get_server_banner();
                 }
                 break;
             }
             break;
 
         case 16:
             if (!strcmp(var, "REQUEST_FILENAME")) {
                 result = r->filename; /* same as script_filename (15) */
             }
             break;
 
         case 21:
             if (!strcmp(var, "HTTP_PROXY_CONNECTION")) {
                 result = lookup_header("Proxy-Connection", ctx);
             }
             break;
         }
     }
 
     return apr_pstrdup(r->pool, result ? result : "");
 }
 
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |                 Expansion functions
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 /*
  * Bracketed expression handling
  * s points after the opening bracket
  */
 static APR_INLINE char *find_closing_curly(char *s)
 {
     unsigned depth;
 
     for (depth = 1; *s; ++s) {
         if (*s == RIGHT_CURLY && --depth == 0) {
             return s;
         }
         else if (*s == LEFT_CURLY) {
             ++depth;
         }
     }
 
     return NULL;
 }
 
 static APR_INLINE char *find_char_in_curlies(char *s, int c)
 {
     unsigned depth;
 
     for (depth = 1; *s; ++s) {
         if (*s == c && depth == 1) {
             return s;
         }
         else if (*s == RIGHT_CURLY && --depth == 0) {
             return NULL;
         }
         else if (*s == LEFT_CURLY) {
             ++depth;
         }
     }
 
     return NULL;
 }
 
 /* perform all the expansions on the input string
  * putting the result into a new string
  *
  * for security reasons this expansion must be performed in a
  * single pass, otherwise an attacker can arrange for the result
  * of an earlier expansion to include expansion specifiers that
  * are interpreted by a later expansion, producing results that
  * were not intended by the administrator.
  */
 static char *do_expand(char *input, rewrite_ctx *ctx, rewriterule_entry *entry)
 {
     result_list *result, *current;
     result_list sresult[SMALL_EXPANSION];
     unsigned spc = 0;
     apr_size_t span, inputlen, outlen;
     char *p, *c;
     apr_pool_t *pool = ctx->r->pool;
 
     span = strcspn(input, "\\$%");
     inputlen = strlen(input);
 
     /* fast exit */
     if (inputlen == span) {
         return apr_pstrdup(pool, input);
     }
 
     /* well, actually something to do */
     result = current = &(sresult[spc++]);
 
     p = input + span;
     current->next = NULL;
     current->string = input;
     current->len = span;
     outlen = span;
 
     /* loop for specials */
     do {
         /* prepare next entry */
         if (current->len) {
             current->next = (spc < SMALL_EXPANSION)
                             ? &(sresult[spc++])
                             : (result_list *)apr_palloc(pool,
                                                         sizeof(result_list));
             current = current->next;
             current->next = NULL;
             current->len = 0;
         }
 
         /* escaped character */
         if (*p == '\\') {
             current->len = 1;
             ++outlen;
             if (!p[1]) {
                 current->string = p;
                 break;
             }
             else {
                 current->string = ++p;
                 ++p;
             }
         }
 
         /* variable or map lookup */
         else if (p[1] == '{') {
             char *endp;
 
             endp = find_closing_curly(p+2);
             if (!endp) {
                 current->len = 2;
                 current->string = p;
                 outlen += 2;
                 p += 2;
             }
 
             /* variable lookup */
             else if (*p == '%') {
                 p = lookup_variable(apr_pstrmemdup(pool, p+2, endp-p-2), ctx);
 
                 span = strlen(p);
                 current->len = span;
                 current->string = p;
                 outlen += span;
                 p = endp + 1;
             }
 
             /* map lookup */
             else {     /* *p == '$' */
                 char *key;
 
                 /*
                  * To make rewrite maps useful, the lookup key and
                  * default values must be expanded, so we make
                  * recursive calls to do the work. For security
                  * reasons we must never expand a string that includes
                  * verbatim data from the network. The recursion here
                  * isn't a problem because the result of expansion is
                  * only passed to lookup_map() so it cannot be
                  * re-expanded, only re-looked-up. Another way of
                  * looking at it is that the recursion is entirely
                  * driven by the syntax of the nested curly brackets.
                  */
 
                 key = find_char_in_curlies(p+2, ':');
                 if (!key) {
                     current->len = 2;
                     current->string = p;
                     outlen += 2;
                     p += 2;
                 }
                 else {
                     char *map, *dflt;
 
                     map = apr_pstrmemdup(pool, p+2, endp-p-2);
                     key = map + (key-p-2);
                     *key++ = '\0';
                     dflt = find_char_in_curlies(key, '|');
                     if (dflt) {
                         *dflt++ = '\0';
                     }
 
                     /* reuse of key variable as result */
                     key = lookup_map(ctx->r, map, do_expand(key, ctx, entry));
 
                     if (!key && dflt && *dflt) {
                         key = do_expand(dflt, ctx, entry);
                     }
 
                     if (key) {
                         span = strlen(key);
                         current->len = span;
                         current->string = key;
                         outlen += span;
                     }
 
                     p = endp + 1;
                 }
             }
         }
 
         /* backreference */
         else if (apr_isdigit(p[1])) {
             int n = p[1] - '0';
             backrefinfo *bri = (*p == '$') ? &ctx->briRR : &ctx->briRC;
 
             /* see ap_pregsub() in server/util.c */
             if (bri->source && n < AP_MAX_REG_MATCH
                 && bri->regmatch[n].rm_eo > bri->regmatch[n].rm_so) {
                 span = bri->regmatch[n].rm_eo - bri->regmatch[n].rm_so;
                 if (entry && (entry->flags & RULEFLAG_ESCAPEBACKREF)) {
                     /* escape the backreference */
                     char *tmp2, *tmp;
-                    tmp = apr_pstrndup(pool, bri->source + bri->regmatch[n].rm_so, span);
-                    tmp2 = ap_escape_path_segment(pool, tmp);
+                    tmp = apr_palloc(pool, span + 1);
+                    strncpy(tmp, bri->source + bri->regmatch[n].rm_so, span);
+                    tmp[span] = '\0';
+                    tmp2 = escape_uri(pool, tmp);
                     rewritelog((ctx->r, 5, ctx->perdir, "escaping backreference '%s' to '%s'",
                             tmp, tmp2));
 
                     current->len = span = strlen(tmp2);
                     current->string = tmp2;
-                }
-                else {
+                } else {
                     current->len = span;
                     current->string = bri->source + bri->regmatch[n].rm_so;
                 }
                 
                 outlen += span;
             }
 
             p += 2;
         }
 
         /* not for us, just copy it */
         else {
             current->len = 1;
             current->string = p++;
             ++outlen;
         }
 
         /* check the remainder */
         if (*p && (span = strcspn(p, "\\$%")) > 0) {
             if (current->len) {
                 current->next = (spc < SMALL_EXPANSION)
                                 ? &(sresult[spc++])
                                 : (result_list *)apr_palloc(pool,
                                                            sizeof(result_list));
                 current = current->next;
                 current->next = NULL;
             }
 
             current->len = span;
             current->string = p;
             p += span;
             outlen += span;
         }
 
     } while (p < input+inputlen);
 
     /* assemble result */
     c = p = apr_palloc(pool, outlen + 1); /* don't forget the \0 */
     do {
         if (result->len) {
             ap_assert(c+result->len <= p+outlen); /* XXX: can be removed after
                                                    * extensive testing and
                                                    * review
                                                    */
             memcpy(c, result->string, result->len);
             c += result->len;
         }
         result = result->next;
     } while (result);
 
     p[outlen] = '\0';
 
     return p;
 }
 
 /*
  * perform all the expansions on the environment variables
  */
 static void do_expand_env(data_item *env, rewrite_ctx *ctx)
 {
     char *name, *val;
 
     while (env) {
         name = do_expand(env->data, ctx, NULL);
         if ((val = ap_strchr(name, ':')) != NULL) {
             *val++ = '\0';
 
             apr_table_set(ctx->r->subprocess_env, name, val);
             rewritelog((ctx->r, 5, NULL, "setting env variable '%s' to '%s'",
                         name, val));
         }
 
         env = env->next;
     }
 
     return;
 }
 
 /*
  * perform all the expansions on the cookies
  *
  * TODO: use cached time similar to how logging does it
  */
 static void add_cookie(request_rec *r, char *s)
 {
     char *var;
     char *val;
     char *domain;
     char *expires;
     char *path;
     char *secure;
     char *httponly;
 
     char *tok_cntx;
     char *cookie;
 
     var = apr_strtok(s, ":", &tok_cntx);
     val = apr_strtok(NULL, ":", &tok_cntx);
     domain = apr_strtok(NULL, ":", &tok_cntx);
 
     if (var && val && domain) {
         request_rec *rmain = r;
         char *notename;
         void *data;
 
         while (rmain->main) {
             rmain = rmain->main;
         }
 
         notename = apr_pstrcat(rmain->pool, var, "_rewrite", NULL);
         apr_pool_userdata_get(&data, notename, rmain->pool);
         if (!data) {
             char *exp_time = NULL;
 
             expires = apr_strtok(NULL, ":", &tok_cntx);
             path = expires ? apr_strtok(NULL, ":", &tok_cntx) : NULL;
             secure = path ? apr_strtok(NULL, ":", &tok_cntx) : NULL;
             httponly = secure ? apr_strtok(NULL, ":", &tok_cntx) : NULL;
 
             if (expires) {
                 apr_time_exp_t tms;
                 apr_time_exp_gmt(&tms, r->request_time
                                      + apr_time_from_sec((60 * atol(expires))));
                 exp_time = apr_psprintf(r->pool, "%s, %.2d-%s-%.4d "
                                                  "%.2d:%.2d:%.2d GMT",
                                         apr_day_snames[tms.tm_wday],
                                         tms.tm_mday,
                                         apr_month_snames[tms.tm_mon],
                                         tms.tm_year+1900,
                                         tms.tm_hour, tms.tm_min, tms.tm_sec);
             }
 
             cookie = apr_pstrcat(rmain->pool,
                                  var, "=", val,
                                  "; path=", path ? path : "/",
                                  "; domain=", domain,
                                  expires ? "; expires=" : NULL,
                                  expires ? exp_time : NULL,
                                  (secure && (!strcasecmp(secure, "true")
                                              || !strcmp(secure, "1")
                                              || !strcasecmp(secure,
                                                             "secure"))) ?
                                   "; secure" : NULL,
                                  (httponly && (!strcasecmp(httponly, "true")
                                                || !strcmp(httponly, "1")
                                                || !strcasecmp(httponly,
                                                               "HttpOnly"))) ?
                                   "; HttpOnly" : NULL,
                                  NULL);
 
             apr_table_addn(rmain->err_headers_out, "Set-Cookie", cookie);
             apr_pool_userdata_set("set", notename, NULL, rmain->pool);
             rewritelog((rmain, 5, NULL, "setting cookie '%s'", cookie));
         }
         else {
             rewritelog((rmain, 5, NULL, "skipping already set cookie '%s'",
                         var));
         }
     }
 
     return;
 }
 
 static void do_expand_cookie(data_item *cookie, rewrite_ctx *ctx)
 {
     while (cookie) {
         add_cookie(ctx->r, do_expand(cookie->data, ctx, NULL));
         cookie = cookie->next;
     }
 
     return;
 }
 
 #if APR_HAS_USER
 /*
  * Expand tilde-paths (/~user) through Unix /etc/passwd
  * database information (or other OS-specific database)
  */
 static char *expand_tildepaths(request_rec *r, char *uri)
 {
     if (uri && *uri == '/' && uri[1] == '~') {
         char *p, *user;
 
         p = user = uri + 2;
         while (*p && *p != '/') {
             ++p;
         }
 
         if (p > user) {
             char *homedir;
 
             user = apr_pstrmemdup(r->pool, user, p-user);
             if (apr_uid_homepath_get(&homedir, user, r->pool) == APR_SUCCESS) {
                 if (*p) {
                     /* reuse of user variable */
                     user = homedir + strlen(homedir) - 1;
                     if (user >= homedir && *user == '/') {
                         *user = '\0';
                     }
 
                     return apr_pstrcat(r->pool, homedir, p, NULL);
                 }
                 else {
                     return homedir;
                 }
             }
         }
     }
 
     return uri;
 }
 #endif  /* if APR_HAS_USER */
 
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |              rewriting lockfile support
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 static apr_status_t rewritelock_create(server_rec *s, apr_pool_t *p)
 {
     apr_status_t rc;
 
     /* only operate if a lockfile is used */
     if (lockname == NULL || *(lockname) == '\0') {
         return APR_SUCCESS;
     }
 
     /* create the lockfile */
     rc = apr_global_mutex_create(&rewrite_mapr_lock_acquire, lockname,
                                  APR_LOCK_DEFAULT, p);
     if (rc != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rc, s,
                      "mod_rewrite: Parent could not create RewriteLock "
                      "file %s", lockname);
         return rc;
     }
 
 #ifdef AP_NEED_SET_MUTEX_PERMS
     rc = unixd_set_global_mutex_perms(rewrite_mapr_lock_acquire);
     if (rc != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rc, s,
                      "mod_rewrite: Parent could not set permissions "
                      "on RewriteLock; check User and Group directives");
         return rc;
     }
 #endif
 
     return APR_SUCCESS;
 }
 
 static apr_status_t rewritelock_remove(void *data)
 {
     /* only operate if a lockfile is used */
     if (lockname == NULL || *(lockname) == '\0') {
         return APR_SUCCESS;
     }
 
     /* destroy the rewritelock */
     apr_global_mutex_destroy (rewrite_mapr_lock_acquire);
     rewrite_mapr_lock_acquire = NULL;
     lockname = NULL;
     return(0);
 }
 
 
 /*
  * +-------------------------------------------------------+
  * |                                                       |
  * |           configuration directive handling
  * |                                                       |
  * +-------------------------------------------------------+
  */
 
 /*
  * own command line parser for RewriteRule and RewriteCond,
  * which doesn't have the '\\' problem.
  * (returns true on error)
  *
  * XXX: what an inclined parser. Seems we have to leave it so
  *      for backwards compat. *sigh*
  */
 static int parseargline(char *str, char **a1, char **a2, char **a3)
 {
     char quote;
 
     while (apr_isspace(*str)) {
         ++str;
     }
 
     /*
      * determine first argument
      */
     quote = (*str == '"' || *str == '\'') ? *str++ : '\0';
     *a1 = str;
 
     for (; *str; ++str) {
         if ((apr_isspace(*str) && !quote) || (*str == quote)) {
             break;
         }
         if (*str == '\\' && apr_isspace(str[1])) {
             ++str;
             continue;
         }
     }
 
     if (!*str) {
         return 1;
     }
     *str++ = '\0';
 
     while (apr_isspace(*str)) {
         ++str;
     }
 
     /*
      * determine second argument
      */
     quote = (*str == '"' || *str == '\'') ? *str++ : '\0';
     *a2 = str;
 
     for (; *str; ++str) {
         if ((apr_isspace(*str) && !quote) || (*str == quote)) {
             break;
         }
         if (*str == '\\' && apr_isspace(str[1])) {
             ++str;
             continue;
         }
     }
 
     if (!*str) {
         *a3 = NULL; /* 3rd argument is optional */
         return 0;
     }
     *str++ = '\0';
 
     while (apr_isspace(*str)) {
         ++str;
     }
 
     if (!*str) {
         *a3 = NULL; /* 3rd argument is still optional */
         return 0;
     }
 
     /*
      * determine third argument
      */
     quote = (*str == '"' || *str == '\'') ? *str++ : '\0';
     *a3 = str;
     for (; *str; ++str) {
         if ((apr_isspace(*str) && !quote) || (*str == quote)) {
             break;
         }
         if (*str == '\\' && apr_isspace(str[1])) {
             ++str;
             continue;
         }
     }
     *str = '\0';
 
     return 0;
 }
 
 static void *config_server_create(apr_pool_t *p, server_rec *s)
 {
     rewrite_server_conf *a;
 
     a = (rewrite_server_conf *)apr_pcalloc(p, sizeof(rewrite_server_conf));
 
     a->state           = ENGINE_DISABLED;
     a->options         = OPTION_NONE;
 #ifndef REWRITELOG_DISABLED
     a->rewritelogfile  = NULL;
     a->rewritelogfp    = NULL;
     a->rewriteloglevel = 0;
 #endif
     a->rewritemaps     = apr_hash_make(p);
     a->rewriteconds    = apr_array_make(p, 2, sizeof(rewritecond_entry));
     a->rewriterules    = apr_array_make(p, 2, sizeof(rewriterule_entry));
     a->server          = s;
 
     return (void *)a;
 }
 
 static void *config_server_merge(apr_pool_t *p, void *basev, void *overridesv)
 {
     rewrite_server_conf *a, *base, *overrides;
 
     a         = (rewrite_server_conf *)apr_pcalloc(p,
                                                    sizeof(rewrite_server_conf));
     base      = (rewrite_server_conf *)basev;
     overrides = (rewrite_server_conf *)overridesv;
 
     a->state   = overrides->state;
     a->options = overrides->options;
     a->server  = overrides->server;
 
     if (a->options & OPTION_INHERIT) {
         /*
          *  local directives override
          *  and anything else is inherited
          */
 #ifndef REWRITELOG_DISABLED
         a->rewriteloglevel = overrides->rewriteloglevel != 0
                              ? overrides->rewriteloglevel
                              : base->rewriteloglevel;
         a->rewritelogfile  = overrides->rewritelogfile != NULL
                              ? overrides->rewritelogfile
                              : base->rewritelogfile;
         a->rewritelogfp    = overrides->rewritelogfp != NULL
                              ? overrides->rewritelogfp
                              : base->rewritelogfp;
 #endif
         a->rewritemaps     = apr_hash_overlay(p, overrides->rewritemaps,
                                               base->rewritemaps);
         a->rewriteconds    = apr_array_append(p, overrides->rewriteconds,
                                               base->rewriteconds);
         a->rewriterules    = apr_array_append(p, overrides->rewriterules,
                                               base->rewriterules);
     }
     else {
         /*
          *  local directives override
          *  and anything else gets defaults
          */
 #ifndef REWRITELOG_DISABLED
         a->rewriteloglevel = overrides->rewriteloglevel;
         a->rewritelogfile  = overrides->rewritelogfile;
         a->rewritelogfp    = overrides->rewritelogfp;
 #endif
         a->rewritemaps     = overrides->rewritemaps;
         a->rewriteconds    = overrides->rewriteconds;
         a->rewriterules    = overrides->rewriterules;
     }
 
     return (void *)a;
 }
 
 static void *config_perdir_create(apr_pool_t *p, char *path)
 {
     rewrite_perdir_conf *a;
 
     a = (rewrite_perdir_conf *)apr_pcalloc(p, sizeof(rewrite_perdir_conf));
 
     a->state           = ENGINE_DISABLED;
     a->options         = OPTION_NONE;
     a->baseurl         = NULL;
     a->rewriteconds    = apr_array_make(p, 2, sizeof(rewritecond_entry));
     a->rewriterules    = apr_array_make(p, 2, sizeof(rewriterule_entry));
 
     if (path == NULL) {
         a->directory = NULL;
     }
     else {
         /* make sure it has a trailing slash */
         if (path[strlen(path)-1] == '/') {
             a->directory = apr_pstrdup(p, path);
         }
         else {
             a->directory = apr_pstrcat(p, path, "/", NULL);
         }
     }
 
     return (void *)a;
 }
 
 static void *config_perdir_merge(apr_pool_t *p, void *basev, void *overridesv)
 {
     rewrite_perdir_conf *a, *base, *overrides;
 
     a         = (rewrite_perdir_conf *)apr_pcalloc(p,
                                                   sizeof(rewrite_perdir_conf));
     base      = (rewrite_perdir_conf *)basev;
     overrides = (rewrite_perdir_conf *)overridesv;
 
     a->state     = overrides->state;
     a->options   = overrides->options;
     a->directory = overrides->directory;
     a->baseurl   = overrides->baseurl;
 
     if (a->options & OPTION_INHERIT) {
         a->rewriteconds = apr_array_append(p, overrides->rewriteconds,
                                            base->rewriteconds);
         a->rewriterules = apr_array_append(p, overrides->rewriterules,
                                            base->rewriterules);
     }
     else {
         a->rewriteconds = overrides->rewriteconds;
         a->rewriterules = overrides->rewriterules;
     }
 
     return (void *)a;
 }
 
 static const char *cmd_rewriteengine(cmd_parms *cmd,
                                      void *in_dconf, int flag)
 {
     rewrite_perdir_conf *dconf = in_dconf;
     rewrite_server_conf *sconf;
 
     sconf = ap_get_module_config(cmd->server->module_config, &rewrite_module);
 
     if (cmd->path == NULL) { /* is server command */
         sconf->state = (flag ? ENGINE_ENABLED : ENGINE_DISABLED);
     }
     else                   /* is per-directory command */ {
         dconf->state = (flag ? ENGINE_ENABLED : ENGINE_DISABLED);
     }
 
     return NULL;
 }
 
 static const char *cmd_rewriteoptions(cmd_parms *cmd,
                                       void *in_dconf, const char *option)
 {
     int options = 0;
     char *w;
 
     while (*option) {
         w = ap_getword_conf(cmd->pool, &option);
 
         if (!strcasecmp(w, "inherit")) {
             options |= OPTION_INHERIT;
         }
         else if (!strncasecmp(w, "MaxRedirects=", 13)) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
                          "RewriteOptions: MaxRedirects option has been "
                          "removed in favor of the global "
                          "LimitInternalRecursion directive and will be "
                          "ignored.");
         }
         else {
             return apr_pstrcat(cmd->pool, "RewriteOptions: unknown option '",
                                w, "'", NULL);
         }
     }
 
     /* put it into the appropriate config */
     if (cmd->path == NULL) { /* is server command */
         rewrite_server_conf *conf =
             ap_get_module_config(cmd->server->module_config,
                                  &rewrite_module);
 
         conf->options |= options;
     }
     else {                  /* is per-directory command */
         rewrite_perdir_conf *conf = in_dconf;
 
         conf->options |= options;
     }
 
     return NULL;
 }
 
 #ifndef REWRITELOG_DISABLED
 static const char *cmd_rewritelog(cmd_parms *cmd, void *dconf, const char *a1)
 {
     rewrite_server_conf *sconf;
 
     sconf = ap_get_module_config(cmd->server->module_config, &rewrite_module);
     sconf->rewritelogfile = a1;
 
     return NULL;
 }
 
 static const char *cmd_rewriteloglevel(cmd_parms *cmd, void *dconf,
                                        const char *a1)
 {
     rewrite_server_conf *sconf;
 
     sconf = ap_get_module_config(cmd->server->module_config, &rewrite_module);
     sconf->rewriteloglevel = atoi(a1);
 
     return NULL;
 }
 #endif /* rewritelog */
 
 static const char *cmd_rewritemap(cmd_parms *cmd, void *dconf, const char *a1,
                                   const char *a2)
 {
     rewrite_server_conf *sconf;
     rewritemap_entry *newmap;
     apr_finfo_t st;
     const char *fname;
 
     sconf = ap_get_module_config(cmd->server->module_config, &rewrite_module);
 
     newmap = apr_palloc(cmd->pool, sizeof(rewritemap_entry));
     newmap->func = NULL;
 
     if (strncasecmp(a2, "txt:", 4) == 0) {
         if ((fname = ap_server_root_relative(cmd->pool, a2+4)) == NULL) {
             return apr_pstrcat(cmd->pool, "RewriteMap: bad path to txt map: ",
                                a2+4, NULL);
         }
 
         newmap->type      = MAPTYPE_TXT;
         newmap->datafile  = fname;
         newmap->checkfile = fname;
         newmap->checkfile2= NULL;
         newmap->cachename = apr_psprintf(cmd->pool, "%pp:%s",
                                          (void *)cmd->server, a1);
     }
     else if (strncasecmp(a2, "rnd:", 4) == 0) {
         if ((fname = ap_server_root_relative(cmd->pool, a2+4)) == NULL) {
             return apr_pstrcat(cmd->pool, "RewriteMap: bad path to rnd map: ",
                                a2+4, NULL);
         }
 
         newmap->type      = MAPTYPE_RND;
         newmap->datafile  = fname;
         newmap->checkfile = fname;
         newmap->checkfile2= NULL;
         newmap->cachename = apr_psprintf(cmd->pool, "%pp:%s",
                                          (void *)cmd->server, a1);
     }
     else if (strncasecmp(a2, "dbm", 3) == 0) {
         apr_status_t rv;
 
         newmap->type = MAPTYPE_DBM;
         fname = NULL;
         newmap->cachename = apr_psprintf(cmd->pool, "%pp:%s",
                                          (void *)cmd->server, a1);
 
         if (a2[3] == ':') {
             newmap->dbmtype = "default";
             fname = a2+4;
         }
         else if (a2[3] == '=') {
             const char *colon = ap_strchr_c(a2 + 4, ':');
 
             if (colon) {
                 newmap->dbmtype = apr_pstrndup(cmd->pool, a2 + 4,
                                                colon - (a2 + 3) - 1);
                 fname = colon + 1;
             }
         }
 
         if (!fname) {
             return apr_pstrcat(cmd->pool, "RewriteMap: bad map:",
                                a2, NULL);
         }
 
         if ((newmap->datafile = ap_server_root_relative(cmd->pool,
                                                         fname)) == NULL) {
             return apr_pstrcat(cmd->pool, "RewriteMap: bad path to dbm map: ",
                                fname, NULL);
         }
 
         rv = apr_dbm_get_usednames_ex(cmd->pool, newmap->dbmtype,
                                       newmap->datafile, &newmap->checkfile,
                                       &newmap->checkfile2);
         if (rv != APR_SUCCESS) {
             return apr_pstrcat(cmd->pool, "RewriteMap: dbm type ",
                                newmap->dbmtype, " is invalid", NULL);
         }
     }
     else if (strncasecmp(a2, "prg:", 4) == 0) {
         apr_tokenize_to_argv(a2 + 4, &newmap->argv, cmd->pool);
 
         fname = newmap->argv[0];
         if ((newmap->argv[0] = ap_server_root_relative(cmd->pool,
                                                        fname)) == NULL) {
             return apr_pstrcat(cmd->pool, "RewriteMap: bad path to prg map: ",
                                fname, NULL);
         }
 
         newmap->type      = MAPTYPE_PRG;
         newmap->datafile  = NULL;
         newmap->checkfile = newmap->argv[0];
         newmap->checkfile2= NULL;
         newmap->cachename = NULL;
     }
     else if (strncasecmp(a2, "int:", 4) == 0) {
         newmap->type      = MAPTYPE_INT;
         newmap->datafile  = NULL;
         newmap->checkfile = NULL;
         newmap->checkfile2= NULL;
         newmap->cachename = NULL;
         newmap->func      = (char *(*)(request_rec *,char *))
                             apr_hash_get(mapfunc_hash, a2+4, strlen(a2+4));
         if ((sconf->state == ENGINE_ENABLED) && (newmap->func == NULL)) {
             return apr_pstrcat(cmd->pool, "RewriteMap: internal map not found:",
                                a2+4, NULL);
         }
     }
     else {
         if ((fname = ap_server_root_relative(cmd->pool, a2)) == NULL) {
             return apr_pstrcat(cmd->pool, "RewriteMap: bad path to txt map: ",
                                a2, NULL);
         }
 
         newmap->type      = MAPTYPE_TXT;
         newmap->datafile  = fname;
         newmap->checkfile = fname;
         newmap->checkfile2= NULL;
         newmap->cachename = apr_psprintf(cmd->pool, "%pp:%s",
                                          (void *)cmd->server, a1);
     }
     newmap->fpin  = NULL;
     newmap->fpout = NULL;
 
     if (newmap->checkfile && (sconf->state == ENGINE_ENABLED)
         && (apr_stat(&st, newmap->checkfile, APR_FINFO_MIN,
                      cmd->pool) != APR_SUCCESS)) {
         return apr_pstrcat(cmd->pool,
                            "RewriteMap: file for map ", a1,
                            " not found:", newmap->checkfile, NULL);
     }
 
     apr_hash_set(sconf->rewritemaps, a1, APR_HASH_KEY_STRING, newmap);
 
     return NULL;
 }
 
 static const char *cmd_rewritelock(cmd_parms *cmd, void *dconf, const char *a1)
 {
     const char *error;
 
     if ((error = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
         return error;
 
     /* fixup the path, especially for rewritelock_remove() */
     lockname = ap_server_root_relative(cmd->pool, a1);
 
     if (!lockname) {
         return apr_pstrcat(cmd->pool, "Invalid RewriteLock path ", a1);
     }
 
     return NULL;
 }
 
 static const char *cmd_rewritebase(cmd_parms *cmd, void *in_dconf,
                                    const char *a1)
 {
     rewrite_perdir_conf *dconf = in_dconf;
 
     if (cmd->path == NULL || dconf == NULL) {
         return "RewriteBase: only valid in per-directory config files";
     }
     if (a1[0] == '\0') {
         return "RewriteBase: empty URL not allowed";
     }
     if (a1[0] != '/') {
         return "RewriteBase: argument is not a valid URL";
     }
 
     dconf->baseurl = a1;
 
     return NULL;
 }
 
 /*
  * generic lexer for RewriteRule and RewriteCond flags.
  * The parser will be passed in as a function pointer
  * and called if a flag was found
  */
 static const char *cmd_parseflagfield(apr_pool_t *p, void *cfg, char *key,
                                       const char *(*parse)(apr_pool_t *,
                                                            void *,
                                                            char *, char *))
 {
     char *val, *nextp, *endp;
     const char *err;
 
     endp = key + strlen(key) - 1;
     if (*key != '[' || *endp != ']') {
         return "RewriteCond: bad flag delimiters";
     }
 
     *endp = ','; /* for simpler parsing */
     ++key;
 
     while (*key) {
         /* skip leading spaces */
         while (apr_isspace(*key)) {
             ++key;
         }
 
         if (!*key || (nextp = ap_strchr(key, ',')) == NULL) { /* NULL should not
                                                                * happen, but ...
                                                                */
             break;
         }
 
         /* strip trailing spaces */
         endp = nextp - 1;
         while (apr_isspace(*endp)) {
             --endp;
         }
         *++endp = '\0';
 
         /* split key and val */
         val = ap_strchr(key, '=');
         if (val) {
             *val++ = '\0';
         }
         else {
             val = endp;
         }
 
         err = parse(p, cfg, key, val);
         if (err) {
             return err;
         }
 
         key = nextp + 1;
     }
 
     return NULL;
 }
 
 static const char *cmd_rewritecond_setflag(apr_pool_t *p, void *_cfg,
                                            char *key, char *val)
 {
     rewritecond_entry *cfg = _cfg;
 
     if (   strcasecmp(key, "nocase") == 0
         || strcasecmp(key, "NC") == 0    ) {
         cfg->flags |= CONDFLAG_NOCASE;
     }
     else if (   strcasecmp(key, "ornext") == 0
              || strcasecmp(key, "OR") == 0    ) {
         cfg->flags |= CONDFLAG_ORNEXT;
     }
     else if (   strcasecmp(key, "novary") == 0
              || strcasecmp(key, "NV") == 0    ) {
         cfg->flags |= CONDFLAG_NOVARY;
     }
     else {
         return apr_pstrcat(p, "RewriteCond: unknown flag '", key, "'", NULL);
     }
     return NULL;
 }
 
 static const char *cmd_rewritecond(cmd_parms *cmd, void *in_dconf,
                                    const char *in_str)
 {
     rewrite_perdir_conf *dconf = in_dconf;
     char *str = apr_pstrdup(cmd->pool, in_str);
     rewrite_server_conf *sconf;
     rewritecond_entry *newcond;
     ap_regex_t *regexp;
     char *a1;
     char *a2;
     char *a3;
     const char *err;
 
     sconf = ap_get_module_config(cmd->server->module_config, &rewrite_module);
 
     /*  make a new entry in the internal temporary rewrite rule list */
     if (cmd->path == NULL) {   /* is server command */
         newcond = apr_array_push(sconf->rewriteconds);
     }
     else {                     /* is per-directory command */
         newcond = apr_array_push(dconf->rewriteconds);
     }
 
     /* parse the argument line ourself
      * a1 .. a3 are substrings of str, which is a fresh copy
      * of the argument line. So we can use a1 .. a3 without
      * copying them again.
      */
     if (parseargline(str, &a1, &a2, &a3)) {
         return apr_pstrcat(cmd->pool, "RewriteCond: bad argument line '", str,
                            "'", NULL);
     }
 
     /* arg1: the input string */
     newcond->input = a1;
 
     /* arg3: optional flags field
      * (this has to be parsed first, because we need to
      *  know if the regex should be compiled with ICASE!)
      */
     newcond->flags = CONDFLAG_NONE;
     if (a3 != NULL) {
         if ((err = cmd_parseflagfield(cmd->pool, newcond, a3,
                                       cmd_rewritecond_setflag)) != NULL) {
             return err;
         }
     }
 
     /* arg2: the pattern */
     if (*a2 == '!') {
         newcond->flags |= CONDFLAG_NOTMATCH;
         ++a2;
     }
 
     /* determine the pattern type */
     newcond->ptype = 0;
     if (*a2 && a2[1]) {
         if (!a2[2] && *a2 == '-') {
             switch (a2[1]) {
             case 'f': newcond->ptype = CONDPAT_FILE_EXISTS; break;
             case 's': newcond->ptype = CONDPAT_FILE_SIZE;   break;
             case 'l': newcond->ptype = CONDPAT_FILE_LINK;   break;
             case 'd': newcond->ptype = CONDPAT_FILE_DIR;    break;
             case 'x': newcond->ptype = CONDPAT_FILE_XBIT;   break;
             case 'U': newcond->ptype = CONDPAT_LU_URL;      break;
             case 'F': newcond->ptype = CONDPAT_LU_FILE;     break;
             }
         }
         else {
             switch (*a2) {
             case '>': newcond->ptype = CONDPAT_STR_GT; break;
             case '<': newcond->ptype = CONDPAT_STR_LT; break;
             case '=': newcond->ptype = CONDPAT_STR_EQ;
                 /* "" represents an empty string */
                 if (*++a2 == '"' && a2[1] == '"' && !a2[2]) {
                     a2 += 2;
                 }
                 break;
             }
         }
     }
 
     if (newcond->ptype && newcond->ptype != CONDPAT_STR_EQ &&
         (newcond->flags & CONDFLAG_NOCASE)) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
                      "RewriteCond: NoCase option for non-regex pattern '%s' "
                      "is not supported and will be ignored.", a2);
         newcond->flags &= ~CONDFLAG_NOCASE;
     }
 
     newcond->pattern = a2;
 
     if (!newcond->ptype) {
         regexp = ap_pregcomp(cmd->pool, a2,
                              AP_REG_EXTENDED | ((newcond->flags & CONDFLAG_NOCASE)
                                              ? AP_REG_ICASE : 0));
         if (!regexp) {
             return apr_pstrcat(cmd->pool, "RewriteCond: cannot compile regular "
                                "expression '", a2, "'", NULL);
         }
 
         newcond->regexp  = regexp;
     }
 
     return NULL;
 }
 
 static const char *cmd_rewriterule_setflag(apr_pool_t *p, void *_cfg,
                                            char *key, char *val)
 {
     rewriterule_entry *cfg = _cfg;
     int error = 0;
 
     switch (*key++) {
     case 'b':
     case 'B':
         if (!*key || !strcasecmp(key, "ackrefescaping")) {
             cfg->flags |= RULEFLAG_ESCAPEBACKREF;
         } 
         else {
             ++error;
         }
         break;
     case 'c':
     case 'C':
         if (!*key || !strcasecmp(key, "hain")) {           /* chain */
             cfg->flags |= RULEFLAG_CHAIN;
         }
         else if (((*key == 'O' || *key == 'o') && !key[1])
                  || !strcasecmp(key, "ookie")) {           /* cookie */
             data_item *cp = cfg->cookie;
 
             if (!cp) {
                 cp = cfg->cookie = apr_palloc(p, sizeof(*cp));
             }
             else {
                 while (cp->next) {
                     cp = cp->next;
                 }
                 cp->next = apr_palloc(p, sizeof(*cp));
                 cp = cp->next;
             }
 
             cp->next = NULL;
             cp->data = val;
         }
         else {
             ++error;
         }
         break;
 
     case 'e':
     case 'E':
         if (!*key || !strcasecmp(key, "nv")) {             /* env */
             data_item *cp = cfg->env;
 
             if (!cp) {
                 cp = cfg->env = apr_palloc(p, sizeof(*cp));
             }
             else {
